// Filename : controller.cpp
//
// This file was initially generated by SpaceStudio but is meant to be modified
// by the user.
#include "controller.h"
#include "spacecomp_pre_cpp.h"
#include <chrono>
#include <cstdlib>

#include <cstdio>

// Do NOT move macros, functions and includes beginning with "spacecomp".

controller::controller(SPACECOMP_CTOR_PARAMS(controller, INDEX))
	: abstract_module(SPACECOMP_MBASE_ARGS(controller, INDEX))
	, SPACECOMP_START_ILIST(controller, INDEX)
	// Other initializers may go here
{
	SPACECOMP_THREAD(controller, INDEX, thread);
}

void controller::compute_speedup() {

//	float mean_sw_exe_time = (float) cumul_time_SW / num_iteration;
	float mean_hw_exe_time = (float) cumul_time_HW / num_iteration;
//	float acc_factor = mean_sw_exe_time / mean_hw_exe_time;

	printf("Moyenne pour %d iterations:\n\n", num_iteration);
//	printf("Execution time SW: %.1f microseconds\n\n", mean_sw_exe_time);
	printf("Execution time HW: %.1f microseconds\n\n", mean_hw_exe_time);
//	printf("Acceleration factor = %.2f\n\n", acc_factor);

}

void controller::thread(SPACECOMP_THREAD_PARAMS(controller, INDEX, thread)) {
	spacecomp_thread_initialize();
	// Prepare the thread's main loop here if needed. Hardware module instances
	// should not have communications (e.g. DeviceRead()) here because some HLS
	// tools consider what comes before the infinite loop to be simple state
	// reset behavior and therefore refuse synthesizing some/all communications
	// here. Place any initialization communications in the "if" below instead.
	printf("%s is running\n", name());
	uint32_t width = 0;
	uint32_t height = 0;
	uint32_t image_size = 0; /* equals to width*height + 2*sizeof(uint32_t) */
	uint32_t image_in_offset = 0;
	uint32_t image_out_offset = 0;
	const bool initializing = spacecomp_thread_loop_start();
	if (initializing) {
		/* read file and write to ddr */
#if MAPPING == HW_MAPPING
		std::string path = spacelib_global::get_project_path() + "/images/image_in.mem";
		FILE* file = fopen(path.c_str(), "rb" );
#else
		FILE* file = fopen("/root/image_in.mem", "rb" );
#endif

		if (file == 0) {
			printf("error while opening input image\n");
			exit(1);
		}
		else {
			/* get file size */
			fseek(file, 0, SEEK_END);
			image_size = ftell(file);
			rewind(file);

			/* allocate an array for the image */
			uint8_t* content = new uint8_t[image_size];

			/* read the whole image */
			uint32_t read_bytes = fread(content, 1, image_size, file );
			if (read_bytes != image_size) {
				printf("error while reading\n");
				exit(1);
			}

			/* get width and height */
			uint32_t width = ((uint32_t*)content)[0];
			uint32_t height = ((uint32_t*)content)[1];

			printf("Dimension: %d x %d\n\n", width, height);

			/* configure register */
			image_in_offset = 0;
			image_out_offset = image_size;
			RegisterWrite(REGISTER_FILE0_ID, IMAGE_IN_OFFSET_REG, image_in_offset);
			RegisterWrite(REGISTER_FILE0_ID, IMAGE_OUT_OFFSET_REG, image_out_offset);
			RegisterWrite(REGISTER_FILE0_ID, IMAGE_SIZE_REG, image_size);

			/* write image into ddr */
			DeviceWrite(ZYNQ_DDR0_ID, image_in_offset, content, image_size);

			/* clean up */
			delete[] content;
			fclose(file);
		}
	}
	for (int i = 0; i < num_iteration; i++) {
		timestamp1_HW = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();
//		printf("Start time HW: %d microseconds\n\n", timestamp1_HW);

		for (unsigned int index = 0; index < SOBEL_GROUP_SIZE; ++index) {
		    ModuleWrite(SOBEL_GROUP[index], SPACE_BLOCKING, i);
		}

		for (unsigned int index = 0; index < SOBEL_GROUP_SIZE; ++index) {
			ModuleRead(SOBEL_GROUP[index], SPACE_BLOCKING);
		}

		timestamp2_HW = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();
//		printf("End time HW: %d microseconds\n\n", timestamp2_HW);

		cumul_time_HW = cumul_time_HW + (timestamp2_HW - timestamp1_HW);
//		printf("Execution time HW: %d microseconds\n\n", cumul_time_HW);
	}

	compute_speedup();

	/* get result */
	uint8_t* content = new uint8_t[image_size];
	DeviceRead(ZYNQ_DDR0_ID, image_out_offset, content, image_size);

#ifdef SPACE_SIMULATION
	/* save output image to image/ folder (via serialization device) during simulation */
	DeviceWrite(SIMULATION_SERIALIZATION0_ID, START_REG, image_size);
	DeviceWrite(SIMULATION_SERIALIZATION0_ID, PIXEL_REG, content, image_size);
	DeviceWrite(SIMULATION_SERIALIZATION0_ID, DONE_REG, 1);
#else /* SPACE_IMPLEMENTATION */
	/* save output image to the sd card during implementation */
	FILE* file = fopen("/root/sdcard/image_out.mem", "wb");

	if (file == 0) {
		printf("error while opening output image\n");
		exit(1);
	}
	else {
		uint32_t written_bytes = fwrite(content, 1, image_size, file);

		if (written_bytes != image_size) {
			printf("error while writing\n");
			exit(1);
		}

		fclose(file);
	}
#endif
	/* clean up */
	delete[] content;
	printf("%s has completed\n", name());
}

#include "spacecomp_post_cpp.h"


