// Filename : controller.cpp
//
// This file was initially generated by SpaceStudio but is meant to be modified
// by the user.
#include "controller.h"
#include "spacecomp_pre_cpp.h"
#include <chrono>
#include <cstdlib>
#include <cstdio>
#include "space_chrono.h"

// Do NOT move macros, functions and includes beginning with "spacecomp".

controller::controller(SPACECOMP_CTOR_PARAMS(controller, INDEX))
	: abstract_module(SPACECOMP_MBASE_ARGS(controller, INDEX))
	, SPACECOMP_START_ILIST(controller, INDEX)
	// Other initializers may go here
{
	SPACECOMP_THREAD(controller, INDEX, thread);
	request_stack(16*1024*1024);
}

void controller::compute_speedup() {

//	float mean_sw_exe_time = (float) cumul_time_SW / num_iteration;
	float mean_hw_exe_time = (float) cumul_time_HW / num_iteration;
//	float acc_factor = mean_sw_exe_time / mean_hw_exe_time;

	printf("Moyenne pour %d iterations:\n\n", num_iteration);
//	printf("Execution time SW: %.1f microseconds\n\n", mean_sw_exe_time);
	printf("Execution time HW: %.1f microseconds\n\n", mean_hw_exe_time);
//	printf("Acceleration factor = %.2f\n\n", acc_factor);

}

void controller::thread(SPACECOMP_THREAD_PARAMS(controller, INDEX, thread)) {
	spacecomp_thread_initialize();
	// Prepare the thread's main loop here if needed. Hardware module instances
	// should not have communications (e.g. DeviceRead()) here because some HLS
	// tools consider what comes before the infinite loop to be simple state
	// reset behavior and therefore refuse synthesizing some/all communications
	// here. Place any initialization communications in the "if" below instead.
	printf("%s is running\n", name());
	uint32_t width = 0;
	uint32_t height = 0;
	uint32_t image_size = 0; /* equals to width*height + 2*sizeof(uint32_t) */
	uint32_t image_in_offset = 0;
	uint32_t image_out_offset = 0;
	const bool initializing = spacecomp_thread_loop_start();

	const double hw_frequency = 100e6;

	// Considering controller in SW
	// SPACECLOCK case 1
	// A software clock that can be read from the software (including on two different processors).
	typedef SPACE_SPACECLOCK_HANDLE_T(controller, 0, thread, SPACE_ID(controller, INDEX)) clk_t;
	SPACE_SPACECLOCK_HANDLE(controller, INDEX, thread, SPACE_ID(controller, INDEX), clk);

	// SPACECLOCK case 2
	// A hardware clock that can be read directly from the software (the hardware clock of a module is exported to a software module implicitly)
	typedef SPACE_SPACECLOCK_HANDLE_T(controller, 0, thread, SPACE_ID(sobel, INDEX)) sobelclk_t;
	SPACE_SPACECLOCK_HANDLE(controller, INDEX, thread, SPACE_ID(sobel, INDEX), sobelclk);
	sobelclk.now();

	// SPACECLOCK case 3
	// We refine the instrumentation and it will be can be read from the hardware explicitly by a ModuleRead/
	sobelclk_t::rep x, y, z;  // x, y and z for communication, execution and complete time resp.
	sobelclk_t::rep cumul_sobel_data_jiffies[SOBEL_GROUP_SIZE][3]; // x, y and z for each slice

	if (initializing) {
		/* read file and write to ddr */
#if MAPPING == HW_MAPPING
		std::string path = spacelib_global::get_project_path() + "/images/image_in.mem";
		FILE* file = fopen(path.c_str(), "rb" );
#else
		FILE* file = fopen("/root/image_in.mem", "rb" );
#endif

		if (file == 0) {
			printf("error while opening input image\n");
			exit(1);
		}
		else {
			/* get file size */
			fseek(file, 0, SEEK_END);
			image_size = ftell(file);
			rewind(file);

			/* allocate an array for the image */
			uint8_t* content = new uint8_t[image_size];

			/* read the whole image */
			uint32_t read_bytes = fread(content, 1, image_size, file );
			if (read_bytes != image_size) {
				printf("error while reading\n");
				exit(1);
			}

			/* get width and height */
			uint32_t width = ((uint32_t*)content)[0];
			uint32_t height = ((uint32_t*)content)[1];

			printf("Dimension: %d x %d\n\n", width, height);

			/* configure register */
			image_in_offset = 0;
			image_out_offset = image_size;
			RegisterWrite(REGISTER_FILE0_ID, IMAGE_IN_OFFSET_REG, image_in_offset);
			RegisterWrite(REGISTER_FILE0_ID, IMAGE_OUT_OFFSET_REG, image_out_offset);
			RegisterWrite(REGISTER_FILE0_ID, IMAGE_SIZE_REG, image_size);

			/* write image into ddr */
			DeviceWrite(ZYNQ_DDR0_ID, image_in_offset, content, image_size);

			/* clean up */
			delete[] content;
			fclose(file);
		}
	}
	for (int i = 0; i < num_iteration; i++) {
		timestamp1_HW = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();
		clk_t::time sobel_start = clk.now();
		sobelclk_t::time sobel_start_sobelclk = sobelclk.now();

//		printf("Start time HW: %d microseconds\n\n", timestamp1_HW);

		for (unsigned int index = 0; index < SOBEL_GROUP_SIZE; ++index) {
		    ModuleWrite(SOBEL_GROUP[index], SPACE_BLOCKING, i);
		}

		for (unsigned int index = 0; index < SOBEL_GROUP_SIZE; ++index) {
			ModuleRead(SOBEL_GROUP[index], SPACE_BLOCKING);
		}
		
		sobelclk_t::time sobel_end_sobelclk = sobelclk.now();
		clk_t::time sobel_end = clk.now();
		
		// We explicitly read form each sobel slice x, y and z (communication, execution and complete time resp.)
		for (unsigned int index = 0; index < SOBEL_GROUP_SIZE; ++index) {
			ModuleRead(SOBEL_GROUP[index], SPACE_BLOCKING, x);
			ModuleRead(SOBEL_GROUP[index], SPACE_BLOCKING, y);
			ModuleRead(SOBEL_GROUP[index], SPACE_BLOCKING, z);
			cumul_sobel_data_jiffies[index][0] = x;
			cumul_sobel_data_jiffies[index][1] = y;
			cumul_sobel_data_jiffies[index][2] = z;
			}
		
		timestamp2_HW = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();
//		printf("End time HW: %d microseconds\n\n", timestamp2_HW);

		cumul_time_HW = cumul_time_HW + (timestamp2_HW - timestamp1_HW);
//		printf("Execution time HW: %d microseconds\n\n", cumul_time_HW);


		compute_speedup();
	
		SpacePrint(
				"Case 1 took %f sec according to the "
				"controller's (software) clock, and case 2 took %f sec according "
				"to sobel's (hardware) clock.\n",
			(sobel_end - sobel_start).to_sec<double>(),
			// For HW clocks, we can't do time.to_sec<double>() yet: the SW doesn't
			// currently measure the hardware frequency to know how to transform ticks
			// into seconds.
			static_cast<double>((sobel_end_sobelclk - sobel_start_sobelclk).jiffies()) / hw_frequency);

		for (unsigned int index = 0; index < SOBEL_GROUP_SIZE; ++index) {
			SpacePrint(
				"\nInstance no: %d\n"
				"Case 3 for communication inside sobel took %f sec according to the sobel's (hardware) clock.\n"
				"Case 3 for computing inside sobel took %f sec according to the sobel's (hardware) clock.\n"
				"Case 3 for complete execution inside sobel  took %f sec according to the sobel's (hardware) clock.\n",
				index,
				static_cast<double>(cumul_sobel_data_jiffies[index][0]) / hw_frequency,
				static_cast<double>(cumul_sobel_data_jiffies[index][1]) / hw_frequency,
				static_cast<double>(cumul_sobel_data_jiffies[index][2]) / hw_frequency);
			}

	}

	/* get result */
	uint8_t* content = new uint8_t[image_size];
	DeviceRead(ZYNQ_DDR0_ID, image_out_offset, content, image_size);

#ifdef SPACE_SIMULATION
	/* save output image to image/ folder (via serialization device) during simulation */
	DeviceWrite(SIMULATION_SERIALIZATION0_ID, START_REG, image_size);
	DeviceWrite(SIMULATION_SERIALIZATION0_ID, PIXEL_REG, content, image_size);
	DeviceWrite(SIMULATION_SERIALIZATION0_ID, DONE_REG, 1);
#else /* SPACE_IMPLEMENTATION */
	/* save output image to the sd card during implementation */
	FILE* file = fopen("/root/sdcard/image_out.mem", "wb");

	if (file == 0) {
		printf("error while opening output image\n");
		exit(1);
	}
	else {
		uint32_t written_bytes = fwrite(content, 1, image_size, file);

		if (written_bytes != image_size) {
			printf("error while writing\n");
			exit(1);
		}

		fclose(file);
	}
#endif
	/* clean up */
	delete[] content;
	printf("%s has completed\n", name());
}

#include "spacecomp_post_cpp.h"


