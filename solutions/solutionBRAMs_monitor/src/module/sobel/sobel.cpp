// Filename : sobel.cpp
//
// This file was initially generated by SpaceStudio but is meant to be modified
// by the user.
#include "sobel.h"
#include "spacecomp_pre_cpp.h"

#include "C:\Users\Tremeaud\Desktop\Poly\INF8500\TP2\Code_de_depart\SpaceStudio_sobel_filter\sobel_filter\import\kernel.h"

#include <cstring>

// Do NOT move macros, functions and includes beginning with "spacecomp".

sobel::sobel(SPACECOMP_CTOR_PARAMS(sobel, INDEX))
	: abstract_module(SPACECOMP_MBASE_ARGS(sobel, INDEX)), SPACECOMP_START_ILIST(sobel, INDEX)
// Other initializers may go here
{
	SPACECOMP_THREAD(sobel, INDEX, thread);
	//	set_stack_size(2*32+1080*1920*8);
	request_stack(10 * 2 * 32 + 1080 * 1920 * 8);
}

void sobel::thread(SPACECOMP_THREAD_PARAMS(sobel, INDEX, thread))
{
	spacecomp_thread_initialize();
	uint32_t input_addr_offset = 0;
	uint32_t output_addr_offset = 0;
	const uint32_t SLICE_NB = SOBEL_GROUP_SIZE;
	const uint32_t img_width = WIDTH * SLICE_NB; /* must be static for hls */
	const uint32_t img_width_slice = WIDTH;		 /* must be static for hls */
	const uint32_t SLICE_INDEX = INDEX * img_width_slice;
	const uint32_t img_height = 1080;				   /* must be static for hls */
	const uint32_t buf_height = 4;					   /* must be static for hls */
	const uint32_t buf_size = buf_height * img_height; /* must be static for hls */

	uint32_t image_size = 0;

	static uint8_t buf_input[3][img_width_slice]; // 3 lines
	static uint8_t buf_output[img_width_slice];	  // 1 line

	// Considering sobel in HW
	// Case 3 A hardware clock can be read from the hardware and it will be sent to Controller
	typedef SPACE_SPACECLOCK_HANDLE_T(sobel, 0, thread, SPACE_ID(sobel, INDEX)) clk_t;
	SPACE_SPACECLOCK_HANDLE(sobel, INDEX, thread, SPACE_ID(sobel, INDEX), clk);
	// x (communication):
	clk_t::time transfer_start = clk_t::time::zero(), transfer_end = clk_t::time::zero(), cumul_transfer = clk_t::time::zero();
	// y (computing):
	clk_t::time computing_start = clk_t::time::zero(), computing_end = clk_t::time::zero(), cumul_computing_time = clk_t::time::zero();
	// z (complete execution:
	clk_t::time global_computing_start = clk_t::time::zero(), global_computing_end = clk_t::time::zero();

	/* narrowed image that contains only pixel */

	// #pragma HLS ARRAY_PARTITION variable=buf_input  complete dim = 0

	// 3 line buffers en BRAM true dual-port, partitionnés par ligne (1 BRAM/ligne)
#pragma HLS RESOURCE variable = buf_input core = RAM_T2P_BRAM
#pragma HLS ARRAY_PARTITION variable = buf_input complete dim = 1

	// Fenêtre 3x3 en registres (complètement partitionnée)
	uint8_t w0[3], w1[3], w2[3];
#pragma HLS ARRAY_PARTITION variable = w0 complete
#pragma HLS ARRAY_PARTITION variable = w1 complete
#pragma HLS ARRAY_PARTITION variable = w2 complete
#pragma HLS DEPENDENCE variable = w0 inter false
#pragma HLS DEPENDENCE variable = w1 inter false
#pragma HLS DEPENDENCE variable = w2 inter false

	uint8_t *buf_output_pixel = buf_output;

	while (1)
	{
		const bool initializing = spacecomp_thread_loop_start();

		unsigned int counterLineRead = 0;
		unsigned int counterLineProcessed = 0;

		/* wait for controller to be ready */
		// Section 1: A completer (1 instruction)
		global_computing_start = clk.now();

		transfer_start = clk_t::time::zero();
		transfer_end = clk_t::time::zero();
		cumul_transfer = clk_t::time::zero();
		computing_start = clk_t::time::zero();
		computing_end = clk_t::time::zero();
		cumul_computing_time = clk_t::time::zero();

		ModuleRead(CONTROLLER0_ID, SPACE_BLOCKING); // ajout

		RegisterRead(REGISTER_FILE0_ID, IMAGE_IN_OFFSET_REG, input_addr_offset);
		RegisterRead(REGISTER_FILE0_ID, IMAGE_OUT_OFFSET_REG, output_addr_offset);
		RegisterRead(REGISTER_FILE0_ID, IMAGE_SIZE_REG, image_size); /* equals 1920*1080 + 8 */

#if INDEX == 0
		/* write width and height into output mem file */
		((uint32_t *)buf_output_pixel)[0] = img_width;
		((uint32_t *)buf_output_pixel)[1] = img_height;
		transfer_start = clk.now();
		DeviceWrite(ZYNQ_DDR0_ID, output_addr_offset, buf_output_pixel, 2 * sizeof(uint32_t));
		transfer_end = clk.now();
		cumul_transfer += transfer_end - transfer_start;
#endif
		output_addr_offset += 2 * sizeof(uint32_t) + SLICE_INDEX;
		input_addr_offset += 2 * sizeof(uint32_t) + SLICE_INDEX;

		// Padding of line 0
	Line0:
		for (unsigned int i = 0; i < img_width_slice; i++)
#pragma HLS unroll
			buf_output_pixel[i] = 0;

		// Section 2: A completer (1 instruction)
		transfer_start = clk.now();
		DeviceWrite(ZYNQ_DDR0_ID, output_addr_offset, buf_output_pixel, img_width_slice); // ajout
		transfer_end = clk.now();
		cumul_transfer += transfer_end - transfer_start;

		output_addr_offset += img_width;

		// Positioning in the buffer for processing
		counterLineProcessed++; // Line 0 has been done above

		/* read  first 3 lines of pixels from DDR */
		for (unsigned int i = 0; i < 3; i++)
		{
			// Section 3: A completer (2 instructions)//
			transfer_start = clk.now();
			DeviceRead(ZYNQ_DDR0_ID, input_addr_offset, buf_input[i], img_width_slice); // ajout
			input_addr_offset += img_width;										// ajout
			transfer_end = clk.now();
			cumul_transfer += transfer_end - transfer_start;
		}
		unsigned int next_line_to_read = 3; // on a déjà lu lignes 0,1,2

		counterLineRead = counterLineRead + 3;

		const int nbIterations = img_height - 2; // line 0 and 1919 not processed

	L1:
		for (unsigned int it = 1; it < nbIterations - 1; it++)
		{
			// Process current line - effet de bord a revoir...
			buf_output_pixel[0] = 0;
			buf_output_pixel[img_width_slice - 1] = 0;

			// mapping circulaire des BRAMs: top/mid/bot
			int top = (it + 2) % 3;
			int mid = it % 3;
			int bot = (it + 1) % 3;

			// initialisation bords gauche: fenêtre "décalée" (pixels fictifs = 0)
			w0[0] = w0[1] = 0;
			w1[0] = w1[1] = 0;
			w2[0] = w2[1] = 0;

		L2:
			computing_start = clk.now();
			for (unsigned int j = 1; j < img_width_slice - 1; ++j)
			{
#pragma HLS pipeline II = 1

				// 1) Lire 1 pixel par ligne depuis les 3 BRAMs (ports READ)
				uint8_t p0 = buf_input[top][j];
				uint8_t p1 = buf_input[mid][j];
				uint8_t p2 = buf_input[bot][j];

				// 2) Mettre à jour la fenêtre 3x3 (shift à gauche, ajout des nouveaux à droite)
				w0[0] = w0[1];
				w0[1] = w0[2];
				w0[2] = p0;
				w1[0] = w1[1];
				w1[1] = w1[2];
				w1[2] = p1;
				w2[0] = w2[1];
				w2[1] = w2[2];
				w2[2] = p2;

				// 3) Calcul Sobel (sur registres), avec gestion des bords colonne

				uint8_t out_gray = 0;
				// Gx
				int xw = 0;
				xw += -((int)w0[0]) + ((int)w0[2]);
				xw += -2 * ((int)w1[0]) + 2 * ((int)w1[2]);
				xw += -((int)w2[0]) + ((int)w2[2]);

				// Gy
				int yw = 0;
				yw += ((int)w0[0]) + 2 * ((int)w0[1]) + ((int)w0[2]);
				yw += -((int)w2[0]) - 2 * ((int)w2[1]) - ((int)w2[2]);

				unsigned ew = (unsigned)((xw < 0 ? -xw : xw) + (yw < 0 ? -yw : yw));
				if (ew > 255u)
					ew = 255u;

				uint8_t edge_val = (uint8_t)(255u - ew);
				// seuillage
				if (edge_val > 200)
					out_gray = 255;
				else if (edge_val < 100)
					out_gray = 0;
				else
					out_gray = edge_val;

				// 4) Écriture du pixel de sortie
				buf_output_pixel[j] = out_gray;
			}
			computing_end = clk.now();
			cumul_computing_time += computing_end - computing_start;
			// 5) Écriture de la ligne:
			printf("Index no %d Ligne no %d dans le buffer termine et est ecrite dans output a la ligne no %d \n", INDEX, counterLineProcessed % 4, counterLineProcessed);
			// Section 4: A completer (2 instructions)
			transfer_start = clk.now();
			DeviceWrite(ZYNQ_DDR0_ID, output_addr_offset, buf_output_pixel, img_width_slice); // ajout
			output_addr_offset += img_width;											  // ajout
			transfer_end = clk.now();
			cumul_transfer += transfer_end - transfer_start;
			counterLineProcessed++;

			// printf("Prochaine ligne a traiter dans le buffer : %d \n", counterLineProcessed % 4);
			//  6) Prochaine ligne:
			if (next_line_to_read < img_height)
			{
				int refill = top; // la plus ancienne
				// Section 5: A completer (2 instructions)
				transfer_start = clk.now();
				DeviceRead(ZYNQ_DDR0_ID, input_addr_offset, buf_input[refill], img_width_slice); // ajout
				input_addr_offset += img_width;											 // ajout
				transfer_end = clk.now();
				cumul_transfer += transfer_end - transfer_start;
				next_line_to_read++;
			}
			// printf("Prochaine ligne a lire en entree: %d \n",counterLineRead);
		}

		// Last Line padding
	Last:
		for (unsigned int i = 0; i < img_width_slice; i++)
#pragma HLS unroll
			buf_output_pixel[i] = 0;

		// Section 6: A completer (1 instruction)
		//
		DeviceWrite(ZYNQ_DDR0_ID, output_addr_offset, buf_output_pixel, img_width_slice); // ajout

		/* notify controller we are done! */
		// Section 7: A completer (1 instruction)	
		ModuleWrite(CONTROLLER0_ID, SPACE_BLOCKING); // ajout
		global_computing_end = clk.now();

		hw_compute_latency(1);
		ModuleWrite(CONTROLLER0_ID, SPACE_BLOCKING, cumul_transfer.jiffies());
		ModuleWrite(CONTROLLER0_ID, SPACE_BLOCKING, cumul_computing_time.jiffies());
		ModuleWrite(CONTROLLER0_ID, SPACE_BLOCKING, (global_computing_end-global_computing_start).jiffies());
	}
}

#include "spacecomp_post_cpp.h"
