// Filename : sobel.cpp
//
// This file was initially generated by SpaceStudio but is meant to be modified
// by the user.
#include "sobel.h"
#include "spacecomp_pre_cpp.h"

// Do NOT move macros, functions and includes beginning with "spacecomp".

sobel::sobel(SPACECOMP_CTOR_PARAMS(sobel, INDEX))
	: abstract_module(SPACECOMP_MBASE_ARGS(sobel, INDEX))
	, SPACECOMP_START_ILIST(sobel, INDEX)
	// Other initializers may go here
{
	SPACECOMP_THREAD(sobel, INDEX, thread);
	request_stack(2*8*1080*1920);
}


void sobel::thread(SPACECOMP_THREAD_PARAMS(sobel, INDEX, thread)) {
	spacecomp_thread_initialize();
	uint32_t input_addr_offset = 0;
	uint32_t output_addr_offset = 0;
//	const uint32_t img_width = 1920; /* must be static for hls */
//	const uint32_t img_height = 1080; /* must be static for hls */

//	const uint32_t img_width = WIDTH; /* must be static for hls */
	const uint32_t img_width = 1920; /* must be static for hls */
	const uint32_t img_height = 1080; /* must be static for hls */
	uint32_t image_size = 0;

	/* whole image with first 8 bytes that contains width and height */
	uint8_t input[img_width * img_height + 2*sizeof(uint32_t)];
	uint8_t output[img_width * img_height + 2*sizeof(uint32_t)];

	/* narrowed image that contains only pixel */
	uint8_t* input_pixel = &input[2*sizeof(uint32_t)];
	uint8_t* output_pixel = &output[2*sizeof(uint32_t)];

	while (1) {
		const bool initializing = spacecomp_thread_loop_start();

		/* wait for controller to be ready */
		ModuleRead(CONTROLLER0_ID, SPACE_BLOCKING);

//		if (initializing) {
			RegisterRead(REGISTER_FILE0_ID, IMAGE_IN_OFFSET_REG, input_addr_offset);
			RegisterRead(REGISTER_FILE0_ID, IMAGE_OUT_OFFSET_REG, output_addr_offset);
			RegisterRead(REGISTER_FILE0_ID, IMAGE_SIZE_REG, image_size); /* equals 1920*1080 + 8 */
//		}

		/* read pixels from memory */
		DeviceRead(ZYNQ_DDR0_ID, input_addr_offset, input, image_size);

		/* perform sobel */
		sobel_operator(input_pixel, output_pixel, img_width, img_height);

		/* write width and height into output mem file */
		((uint32_t*)output)[0] = img_width;
		((uint32_t*)output)[1] = img_height;

		/* write output image */
		DeviceWrite(ZYNQ_DDR0_ID, output_addr_offset, output, image_size);

		/* notify controller we are done! */
		ModuleWrite(CONTROLLER0_ID, SPACE_BLOCKING);

		hw_compute_latency(1);
	}
}

void sobel::sobel_operator(uint8_t* input, uint8_t* output, uint32_t img_width, uint32_t img_height) {
	uint32_t image_size = img_width*img_height;

	// For simplicity, assume that the borders don't contain edges
	for (unsigned int i = 0; i < img_width; ++i)
		input[i] = 0;
	for (unsigned int i = image_size - img_width; i < image_size; ++i)
		input[i] = 0;
	for (unsigned int i = 0; i < image_size; i += img_width)
		input[i] = 0;
	for (unsigned int i = img_width - 1; i < image_size; i += img_width)
		input[i] = 0;

	// Calling Sobel Operator  for each pixel
	for (unsigned int i = 1; i < img_height - 1; ++i) {
		for (unsigned int j = 1; j < img_width - 1; ++j) {
			int fullIndex = i * img_width + j;
			output[fullIndex] = perform_kernel(fullIndex, img_width, input);
		}
	}
}

uint8_t sobel::perform_kernel(const uint32_t index, const uint32_t img_width, uint8_t* input) {
	int x_weight = 0;
	int y_weight = 0;

	unsigned edge_weight;
	uint8_t edge_val;

	static const signed char x_op[3][3] =
	{ { -1,0,1 },
	{ -2,0,2 },
	{ -1,0,1 } };

	static const signed char y_op[3][3] =
	{ { 1,2,1 },
	{ 0,0,0 },
	{ -1,-2,-1 } };

	//Compute approximation of the gradients in the X-Y direction
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			// X direction gradient
			x_weight = x_weight + (getVal(index, i - 1, j - 1, img_width, input) * x_op[i][j]);

			// Y direction gradient
			y_weight = y_weight + (getVal(index, i - 1, j - 1, img_width, input) * y_op[i][j]);
		}
	}

//		edge_weight = std::abs(x_weight) + std::abs(y_weight);
		if (x_weight < 0)  x_weight = x_weight * -1;
		if (y_weight < 0)  y_weight = y_weight * -1;
		edge_weight = x_weight + y_weight;

		edge_val = (255 - (uint8_t)(edge_weight));

		//Edge thresholding
		if (edge_val > 200)
			edge_val = 255;
		else if (edge_val < 100)
			edge_val = 0;

		return edge_val;
}

uint8_t sobel::getVal(int index, int xDiff, int yDiff, int img_width, uint8_t* input) {
	return input[index + (yDiff * img_width) + xDiff];
};

#include "spacecomp_post_cpp.h"
